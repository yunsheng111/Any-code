//! Gemini Provider Management
//!
//! Handles Gemini provider configuration including:
//! - Provider presets management
//! - Environment configuration (.env file)
//! - Settings.json management
//! - Provider switching

use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::fs;
use std::path::PathBuf;

use super::config::get_gemini_dir;

// ============================================================================
// Type Definitions
// ============================================================================

/// Gemini provider configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct GeminiProviderConfig {
    pub id: String,
    pub name: String,
    pub description: Option<String>,
    pub website_url: Option<String>,
    pub category: Option<String>,
    pub env: HashMap<String, String>, // Environment variables for .env file
    pub is_official: Option<bool>,
    pub is_partner: Option<bool>,
    pub created_at: Option<i64>,
}

/// Current Gemini configuration from ~/.gemini directory
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct CurrentGeminiProviderConfig {
    pub env: HashMap<String, String>,       // ~/.gemini/.env content
    pub settings: serde_json::Value,        // ~/.gemini/settings.json content
    pub api_key: Option<String>,            // Extracted from env
    pub base_url: Option<String>,           // Extracted from env
    pub model: Option<String>,              // Extracted from env
    pub selected_auth_type: Option<String>, // From settings.json
}

// ============================================================================
// Path Utilities
// ============================================================================

/// Get Gemini .env file path
fn get_gemini_env_path() -> Result<PathBuf, String> {
    Ok(get_gemini_dir()?.join(".env"))
}

/// Get Gemini settings.json file path
fn get_gemini_settings_path() -> Result<PathBuf, String> {
    Ok(get_gemini_dir()?.join("settings.json"))
}

/// Get Gemini providers.json path (for custom presets storage)
fn get_gemini_providers_path() -> Result<PathBuf, String> {
    let home = dirs::home_dir().ok_or("Failed to get home directory")?;
    Ok(home.join(".anycode").join("gemini_providers.json"))
}

// ============================================================================
// .env File Operations
// ============================================================================

/// Read .env file and parse into HashMap
fn read_env_file(path: &PathBuf) -> Result<HashMap<String, String>, String> {
    if !path.exists() {
        return Ok(HashMap::new());
    }

    let content =
        fs::read_to_string(path).map_err(|e| format!("Failed to read .env file: {}", e))?;

    let mut env_map = HashMap::new();
    for line in content.lines() {
        let line = line.trim();
        // Skip comments and empty lines
        if line.is_empty() || line.starts_with('#') {
            continue;
        }
        // Parse KEY=VALUE
        if let Some(pos) = line.find('=') {
            let key = line[..pos].trim().to_string();
            let value = line[pos + 1..].trim().to_string();
            // Remove quotes if present
            let value = value.trim_matches('"').trim_matches('\'').to_string();
            env_map.insert(key, value);
        }
    }

    Ok(env_map)
}

/// Write HashMap to .env file
fn write_env_file(path: &PathBuf, env_map: &HashMap<String, String>) -> Result<(), String> {
    // Ensure parent directory exists
    if let Some(parent) = path.parent() {
        fs::create_dir_all(parent).map_err(|e| format!("Failed to create directory: {}", e))?;
    }

    let mut content = String::new();
    content.push_str("# Gemini CLI Configuration\n");
    content.push_str("# Generated by AnyCode\n\n");

    for (key, value) in env_map {
        // Quote values with spaces
        if value.contains(' ') || value.contains('"') {
            content.push_str(&format!("{}=\"{}\"\n", key, value.replace('"', "\\\"")));
        } else {
            content.push_str(&format!("{}={}\n", key, value));
        }
    }

    fs::write(path, content).map_err(|e| format!("Failed to write .env file: {}", e))
}

// ============================================================================
// settings.json Operations
// ============================================================================

/// Read settings.json
fn read_settings_file(path: &PathBuf) -> Result<serde_json::Value, String> {
    if !path.exists() {
        return Ok(serde_json::json!({}));
    }

    let content =
        fs::read_to_string(path).map_err(|e| format!("Failed to read settings.json: {}", e))?;

    serde_json::from_str(&content).map_err(|e| format!("Failed to parse settings.json: {}", e))
}

/// Write settings.json (preserves existing fields like mcpServers)
fn write_settings_file(path: &PathBuf, settings: &serde_json::Value) -> Result<(), String> {
    // Ensure parent directory exists
    if let Some(parent) = path.parent() {
        fs::create_dir_all(parent).map_err(|e| format!("Failed to create directory: {}", e))?;
    }

    let content = serde_json::to_string_pretty(settings)
        .map_err(|e| format!("Failed to serialize settings: {}", e))?;

    fs::write(path, content).map_err(|e| format!("Failed to write settings.json: {}", e))
}

/// Set selected auth type in settings.json
fn set_auth_type_in_settings(settings: &mut serde_json::Value, auth_type: &str) {
    // Ensure security.auth.selectedType structure exists
    if settings.get("security").is_none() {
        settings["security"] = serde_json::json!({});
    }
    if settings["security"].get("auth").is_none() {
        settings["security"]["auth"] = serde_json::json!({});
    }
    settings["security"]["auth"]["selectedType"] = serde_json::Value::String(auth_type.to_string());
}

// ============================================================================
// Tauri Commands
// ============================================================================

/// Get custom Gemini provider presets
#[tauri::command]
pub async fn get_gemini_provider_presets() -> Result<Vec<GeminiProviderConfig>, String> {
    log::info!("[Gemini Provider] Getting provider presets");

    let providers_path = get_gemini_providers_path()?;

    if !providers_path.exists() {
        return Ok(vec![]);
    }

    let content = fs::read_to_string(&providers_path)
        .map_err(|e| format!("Failed to read providers.json: {}", e))?;

    let providers: Vec<GeminiProviderConfig> = serde_json::from_str(&content)
        .map_err(|e| format!("Failed to parse providers.json: {}", e))?;

    Ok(providers)
}

/// Get current Gemini configuration
#[tauri::command]
pub async fn get_current_gemini_provider_config() -> Result<CurrentGeminiProviderConfig, String> {
    log::info!("[Gemini Provider] Getting current config");

    let env_path = get_gemini_env_path()?;
    let settings_path = get_gemini_settings_path()?;

    // Read .env
    let env = read_env_file(&env_path)?;

    // Read settings.json
    let settings = read_settings_file(&settings_path)?;

    // Extract values
    let api_key = env
        .get("GEMINI_API_KEY")
        .or_else(|| env.get("GOOGLE_API_KEY"))
        .cloned();

    let base_url = env.get("GOOGLE_GEMINI_BASE_URL").cloned();
    let model = env.get("GEMINI_MODEL").cloned();

    // Get selected auth type from settings
    let selected_auth_type = settings
        .get("security")
        .and_then(|s| s.get("auth"))
        .and_then(|a| a.get("selectedType"))
        .and_then(|t| t.as_str())
        .map(|s| s.to_string());

    Ok(CurrentGeminiProviderConfig {
        env,
        settings,
        api_key,
        base_url,
        model,
        selected_auth_type,
    })
}

/// Switch to a Gemini provider configuration
#[tauri::command]
pub async fn switch_gemini_provider(config: GeminiProviderConfig) -> Result<String, String> {
    log::info!("[Gemini Provider] Switching to provider: {}", config.name);

    let gemini_dir = get_gemini_dir()?;
    let env_path = get_gemini_env_path()?;
    let settings_path = get_gemini_settings_path()?;

    // Ensure config directory exists
    if !gemini_dir.exists() {
        fs::create_dir_all(&gemini_dir)
            .map_err(|e| format!("Failed to create .gemini directory: {}", e))?;
    }

    // Read existing settings to preserve mcpServers and other user configs
    let mut settings = read_settings_file(&settings_path)?;

    // Determine if this is official (OAuth) or third-party (API Key)
    let is_official = config.is_official.unwrap_or(false)
        || config.category.as_deref() == Some("official")
        || (config
            .env
            .get("GOOGLE_GEMINI_BASE_URL")
            .map_or(true, |s| s.is_empty())
            && config
                .env
                .get("GEMINI_API_KEY")
                .map_or(true, |s| s.is_empty()));

    if is_official {
        // Official (OAuth): Clear env and set auth type to oauth-personal
        log::info!("[Gemini Provider] Setting up for OAuth mode");

        // Clear .env (or write empty)
        write_env_file(&env_path, &HashMap::new())?;

        // Set auth type to oauth-personal
        set_auth_type_in_settings(&mut settings, "oauth-personal");
    } else {
        // Third-party (API Key): Write env and set auth type to gemini-api-key
        log::info!("[Gemini Provider] Setting up for API Key mode");

        // Write .env
        write_env_file(&env_path, &config.env)?;

        // Set auth type to gemini-api-key
        set_auth_type_in_settings(&mut settings, "gemini-api-key");
    }

    // Write settings.json
    write_settings_file(&settings_path, &settings)?;

    log::info!(
        "[Gemini Provider] Successfully switched to: {}",
        config.name
    );
    Ok(format!("成功切换到 Gemini 供应商: {}", config.name))
}

/// Add a new Gemini provider configuration
#[tauri::command]
pub async fn add_gemini_provider_config(config: GeminiProviderConfig) -> Result<String, String> {
    log::info!("[Gemini Provider] Adding provider: {}", config.name);

    let providers_path = get_gemini_providers_path()?;

    // Ensure parent directory exists
    if let Some(parent) = providers_path.parent() {
        if !parent.exists() {
            fs::create_dir_all(parent).map_err(|e| format!("Failed to create directory: {}", e))?;
        }
    }

    // Load existing providers
    let mut providers: Vec<GeminiProviderConfig> = if providers_path.exists() {
        let content = fs::read_to_string(&providers_path)
            .map_err(|e| format!("Failed to read providers.json: {}", e))?;
        serde_json::from_str(&content).unwrap_or_default()
    } else {
        vec![]
    };

    // Check for duplicate ID
    if providers.iter().any(|p| p.id == config.id) {
        return Err(format!("Provider with ID '{}' already exists", config.id));
    }

    providers.push(config.clone());

    // Save providers
    let content = serde_json::to_string_pretty(&providers)
        .map_err(|e| format!("Failed to serialize providers: {}", e))?;
    fs::write(&providers_path, content)
        .map_err(|e| format!("Failed to write providers.json: {}", e))?;

    log::info!(
        "[Gemini Provider] Successfully added provider: {}",
        config.name
    );
    Ok(format!("成功添加 Gemini 供应商: {}", config.name))
}

/// Update an existing Gemini provider configuration
#[tauri::command]
pub async fn update_gemini_provider_config(config: GeminiProviderConfig) -> Result<String, String> {
    log::info!("[Gemini Provider] Updating provider: {}", config.name);

    let providers_path = get_gemini_providers_path()?;

    if !providers_path.exists() {
        return Err(format!("Provider with ID '{}' not found", config.id));
    }

    let content = fs::read_to_string(&providers_path)
        .map_err(|e| format!("Failed to read providers.json: {}", e))?;
    let mut providers: Vec<GeminiProviderConfig> = serde_json::from_str(&content)
        .map_err(|e| format!("Failed to parse providers.json: {}", e))?;

    // Find and update the provider
    let index = providers
        .iter()
        .position(|p| p.id == config.id)
        .ok_or_else(|| format!("Provider with ID '{}' not found", config.id))?;

    providers[index] = config.clone();

    // Save providers
    let content = serde_json::to_string_pretty(&providers)
        .map_err(|e| format!("Failed to serialize providers: {}", e))?;
    fs::write(&providers_path, content)
        .map_err(|e| format!("Failed to write providers.json: {}", e))?;

    log::info!(
        "[Gemini Provider] Successfully updated provider: {}",
        config.name
    );
    Ok(format!("成功更新 Gemini 供应商: {}", config.name))
}

/// Delete a Gemini provider configuration
#[tauri::command]
pub async fn delete_gemini_provider_config(id: String) -> Result<String, String> {
    log::info!("[Gemini Provider] Deleting provider: {}", id);

    let providers_path = get_gemini_providers_path()?;

    if !providers_path.exists() {
        return Err(format!("Provider with ID '{}' not found", id));
    }

    let content = fs::read_to_string(&providers_path)
        .map_err(|e| format!("Failed to read providers.json: {}", e))?;
    let mut providers: Vec<GeminiProviderConfig> = serde_json::from_str(&content)
        .map_err(|e| format!("Failed to parse providers.json: {}", e))?;

    // Find and remove the provider
    let initial_len = providers.len();
    providers.retain(|p| p.id != id);

    if providers.len() == initial_len {
        return Err(format!("Provider with ID '{}' not found", id));
    }

    // Save providers
    let content = serde_json::to_string_pretty(&providers)
        .map_err(|e| format!("Failed to serialize providers: {}", e))?;
    fs::write(&providers_path, content)
        .map_err(|e| format!("Failed to write providers.json: {}", e))?;

    log::info!("[Gemini Provider] Successfully deleted provider: {}", id);
    Ok(format!("成功删除 Gemini 供应商: {}", id))
}

/// Clear Gemini provider configuration (reset to official OAuth)
#[tauri::command]
pub async fn clear_gemini_provider_config() -> Result<String, String> {
    log::info!("[Gemini Provider] Clearing config");

    let env_path = get_gemini_env_path()?;
    let settings_path = get_gemini_settings_path()?;

    // Clear .env
    write_env_file(&env_path, &HashMap::new())?;

    // Reset auth type to OAuth in settings
    let mut settings = read_settings_file(&settings_path)?;
    set_auth_type_in_settings(&mut settings, "oauth-personal");
    write_settings_file(&settings_path, &settings)?;

    log::info!("[Gemini Provider] Successfully cleared config");
    Ok("成功清理 Gemini 配置，已切换回官方 OAuth 模式".to_string())
}

/// Test Gemini provider connection
#[tauri::command]
pub async fn test_gemini_provider_connection(
    base_url: String,
    api_key: Option<String>,
) -> Result<String, String> {
    log::info!("[Gemini Provider] Testing connection to: {}", base_url);

    // Simple connectivity test
    let client = reqwest::Client::builder()
        .timeout(std::time::Duration::from_secs(10))
        .build()
        .map_err(|e| format!("Failed to create HTTP client: {}", e))?;

    let test_url = format!("{}/models", base_url.trim_end_matches('/'));

    let mut request = client.get(&test_url);

    if let Some(key) = api_key {
        // Gemini API uses x-goog-api-key header
        request = request.header("x-goog-api-key", key);
    }

    match request.send().await {
        Ok(response) => {
            let status = response.status();
            if status.is_success() || status.as_u16() == 401 {
                Ok(format!("连接测试成功: 端点可达 (状态: {})", status))
            } else {
                Ok(format!("连接测试完成，状态: {}", status))
            }
        }
        Err(e) => Err(format!("连接测试失败: {}", e)),
    }
}
