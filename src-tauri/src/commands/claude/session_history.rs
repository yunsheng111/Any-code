use std::fs;
use std::io::{BufRead, BufReader};
use std::path::Path;
use std::time::SystemTime;

use chrono::{DateTime, Utc};
use serde_json::Value;

use super::models::JsonlEntry;
use super::paths::get_claude_dir;

/// Extracts the first valid user message from a JSONL file
pub fn extract_first_user_message<P: AsRef<Path>>(
    jsonl_path: P,
) -> (Option<String>, Option<String>) {
    let file = match fs::File::open(jsonl_path) {
        Ok(file) => file,
        Err(_) => return (None, None),
    };

    let reader = BufReader::new(file);

    for line in reader.lines() {
        if let Ok(line) = line {
            if let Ok(entry) = serde_json::from_str::<JsonlEntry>(&line) {
                if let Some(message) = entry.message {
                    if message.role.as_deref() == Some("user") {
                        if let Some(content_value) = message.content {
                            // 提取文本内容（支持字符串和数组两种格式）
                            let mut extracted_text = String::new();
                            let mut has_text_content = false;

                            if let Some(text) = content_value.as_str() {
                                // 字符串格式
                                extracted_text = text.to_string();
                                has_text_content = !text.trim().is_empty();
                            } else if let Some(arr) = content_value.as_array() {
                                // 数组格式（可能包含 text 和 tool_result）
                                for item in arr {
                                    if let Some(item_type) =
                                        item.get("type").and_then(|t| t.as_str())
                                    {
                                        if item_type == "text" {
                                            if let Some(text) =
                                                item.get("text").and_then(|t| t.as_str())
                                            {
                                                extracted_text.push_str(text);
                                                has_text_content = true;
                                            }
                                        }
                                    }
                                }
                            }

                            // 必须有文本内容
                            if !has_text_content {
                                continue;
                            }

                            // Skip if it contains the caveat message
                            if extracted_text.contains("Caveat: The messages below were generated by the user while running local commands") {
                                continue;
                            }

                            // Skip if it starts with command tags
                            if extracted_text.starts_with("<command-name>")
                                || extracted_text.starts_with("<local-command-stdout>")
                            {
                                continue;
                            }

                            // Skip Warmup messages (auto-sent on session start)
                            if extracted_text.contains("Warmup") {
                                continue;
                            }

                            // Found a valid user message
                            return (Some(extracted_text), entry.timestamp);
                        }
                    }
                }
            }
        }
    }

    (None, None)
}

/// Extracts the timestamp of the last message (user or assistant) from a JSONL file
pub fn extract_last_message_timestamp<P: AsRef<Path>>(jsonl_path: P) -> Option<String> {
    let file = match fs::File::open(jsonl_path) {
        Ok(file) => file,
        Err(_) => return None,
    };

    let reader = BufReader::new(file);
    let mut last_timestamp: Option<String> = None;

    for line in reader.lines() {
        if let Ok(line) = line {
            if let Ok(entry) = serde_json::from_str::<JsonlEntry>(&line) {
                // Check if this entry has a message (user or assistant)
                if entry.message.is_some() {
                    // Update last_timestamp if this entry has a timestamp
                    if let Some(timestamp) = entry.timestamp {
                        last_timestamp = Some(timestamp);
                    }
                }
            }
        }
    }

    last_timestamp
}

/// Extracts the model used in the session from a JSONL file
/// Looks for model information in system init messages or assistant messages
pub fn extract_session_model<P: AsRef<Path>>(jsonl_path: P) -> Option<String> {
    let file = match fs::File::open(jsonl_path) {
        Ok(file) => file,
        Err(_) => return None,
    };

    let reader = BufReader::new(file);
    let mut last_model: Option<String> = None;

    for line in reader.lines() {
        if let Ok(line) = line {
            // Try to parse as a generic JSON value first
            if let Ok(entry) = serde_json::from_str::<Value>(&line) {
                // Check for model in different locations:
                // 1. System init message: { "type": "system", "model": "..." }
                // 2. Assistant message: { "type": "assistant", "message": { "model": "..." } }

                if let Some(model_str) = entry.get("model").and_then(|m| m.as_str()) {
                    last_model = Some(model_str.to_string());
                } else if let Some(message) = entry.get("message") {
                    if let Some(model_str) = message.get("model").and_then(|m| m.as_str()) {
                        last_model = Some(model_str.to_string());
                    }
                }
            }
        }
    }

    last_model
}

/// Loads the JSONL history for a specific session
/// Also loads subagent messages from agent-*.jsonl files and merges them
pub fn load_session_history(session_id: &str, project_id: &str) -> Result<Vec<Value>, String> {
    log::info!(
        "Loading session history for session: {} in project: {}",
        session_id,
        project_id
    );

    let claude_dir = get_claude_dir().map_err(|e| e.to_string())?;
    let project_dir = claude_dir.join("projects").join(project_id);
    let session_path = project_dir.join(format!("{}.jsonl", session_id));

    if !session_path.exists() {
        return Err(format!("Session file not found: {}", session_id));
    }

    // Get file modification time as base timestamp
    let file_metadata =
        fs::metadata(&session_path).map_err(|e| format!("Failed to read file metadata: {}", e))?;
    let base_time = file_metadata
        .modified()
        .unwrap_or_else(|_| SystemTime::now());

    let file =
        fs::File::open(&session_path).map_err(|e| format!("Failed to open session file: {}", e))?;

    let reader = BufReader::new(file);
    let mut messages = Vec::new();

    // Step 1: Load main session messages and build agentId -> tool_use_id mapping
    let mut agent_to_tool_use_id: std::collections::HashMap<String, String> =
        std::collections::HashMap::new();

    for line in reader.lines() {
        if let Ok(line) = line {
            if let Ok(json) = serde_json::from_str::<Value>(&line) {
                // Check for tool_result with agentId to build mapping
                if let Some(content) = json
                    .get("message")
                    .and_then(|m| m.get("content"))
                    .and_then(|c| c.as_array())
                {
                    for item in content {
                        if item.get("type").and_then(|t| t.as_str()) == Some("tool_result") {
                            // Get tool_use_id and agentId from toolUseResult
                            if let (Some(tool_use_id), Some(agent_id)) = (
                                item.get("tool_use_id").and_then(|t| t.as_str()),
                                json.get("toolUseResult")
                                    .and_then(|r| r.get("agentId"))
                                    .and_then(|a| a.as_str()),
                            ) {
                                log::debug!(
                                    "Found agentId mapping: {} -> {}",
                                    agent_id,
                                    tool_use_id
                                );
                                agent_to_tool_use_id
                                    .insert(agent_id.to_string(), tool_use_id.to_string());
                            }
                        }
                    }
                }
                messages.push(json);
            }
        }
    }

    log::info!(
        "Found {} agent-to-tool_use_id mappings",
        agent_to_tool_use_id.len()
    );

    // Step 2: Load subagent messages from agent-*.jsonl files
    if !agent_to_tool_use_id.is_empty() {
        if let Ok(entries) = fs::read_dir(&project_dir) {
            for entry in entries.flatten() {
                let path = entry.path();
                if let Some(file_name) = path.file_name().and_then(|n| n.to_str()) {
                    // Match agent-*.jsonl files
                    if file_name.starts_with("agent-") && file_name.ends_with(".jsonl") {
                        // Extract agentId from filename (e.g., "agent-aa740fde.jsonl" -> "aa740fde")
                        let agent_id = file_name
                            .strip_prefix("agent-")
                            .and_then(|s| s.strip_suffix(".jsonl"))
                            .unwrap_or("");

                        // Check if this agent belongs to our session
                        if let Some(tool_use_id) = agent_to_tool_use_id.get(agent_id) {
                            log::info!(
                                "Loading subagent file: {} for tool_use_id: {}",
                                file_name,
                                tool_use_id
                            );

                            // Load subagent messages
                            if let Ok(file) = fs::File::open(&path) {
                                let reader = BufReader::new(file);
                                for line in reader.lines() {
                                    if let Ok(line) = line {
                                        if let Ok(mut json) = serde_json::from_str::<Value>(&line) {
                                            // Verify this subagent belongs to our session
                                            let subagent_session_id =
                                                json.get("sessionId").and_then(|s| s.as_str());
                                            if subagent_session_id == Some(session_id) {
                                                // Add parent_tool_use_id to link subagent messages to Task
                                                json["parent_tool_use_id"] =
                                                    Value::String(tool_use_id.clone());
                                                messages.push(json);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    // Step 3: Sort messages by timestamp to maintain chronological order
    messages.sort_by(|a, b| {
        let ts_a = a.get("timestamp").and_then(|t| t.as_str()).unwrap_or("");
        let ts_b = b.get("timestamp").and_then(|t| t.as_str()).unwrap_or("");
        ts_a.cmp(ts_b)
    });

    // Add timestamps to historical messages that don't have them
    let messages_count = messages.len();
    for (i, message) in messages.iter_mut().enumerate() {
        let message_type = message.get("type").and_then(|t| t.as_str()).unwrap_or("");

        // Calculate timestamp for this message (5 second intervals, older messages get earlier timestamps)
        let time_offset = (messages_count - i - 1) as u64 * 5; // 5 seconds between messages
        let message_time = base_time - std::time::Duration::from_secs(time_offset);
        let timestamp_iso = DateTime::<Utc>::from(message_time).to_rfc3339();

        // Set appropriate timestamp fields based on message type, only if they don't exist
        match message_type {
            "user" => {
                if !message.get("sentAt").is_some() {
                    message["sentAt"] = Value::String(timestamp_iso.clone());
                }
            }
            "assistant" | "system" | "result" => {
                if !message.get("receivedAt").is_some() {
                    message["receivedAt"] = Value::String(timestamp_iso.clone());
                }
            }
            _ => {
                // For unknown types, add receivedAt
                if !message.get("receivedAt").is_some() {
                    message["receivedAt"] = Value::String(timestamp_iso.clone());
                }
            }
        }
    }

    log::info!(
        "Loaded {} total messages (including subagent messages)",
        messages.len()
    );
    Ok(messages)
}
